from dataclasses import asdict, dataclass, field
from pathlib import Path
import yaml
import uuid
import re
from typing import Any


from scripts.shared.constants import FRONTMATTER_BANNER, FRONTMATTER_DELIMITER, VALID_FRONTMATTER_FIELDS, VALID_TAGS, FrontmatterField
from scripts.shared.models import Frontmatter, ValidationResult, DeleteNoteRequest


def is_frontmatter_present(file_data: str) -> dict[str, Any] | None:
    """Parse and return the YAML frontmatter if present; return None otherwise."""
    frontmatter_match = re.search(r"^---\s*\n(.*?)\n---", file_data, re.DOTALL)
    if not frontmatter_match:
        return None
    return yaml.safe_load(frontmatter_match.group(1))

def check_frontmatter_validity(frontmatter : dict[str, Any]) -> ValidationResult:
    errors : list[str] = []

    invalid_keys = set(frontmatter) - set(VALID_FRONTMATTER_FIELDS)
    missing_keys = set(VALID_FRONTMATTER_FIELDS) - set(frontmatter)
    for key in sorted(invalid_keys):
        errors.append(f"Unexpected key: {key}")
    for key in sorted(missing_keys):
        errors.append(f"Missing required key: {key}")
    
    for key, value in frontmatter.items():
        match key:
            case ( FrontmatterField.TITLE.value | FrontmatterField.DESCRIPTION.value | FrontmatterField.CATEGORY.value | FrontmatterField.ID.value):
                if not(isinstance(value, str) and value):
                    if key == FrontmatterField.ID.value:
                        errorMessage = f"'{key}' is automatically generated by this pre-commit script. It was removed or missing"
                    else:
                        errorMessage = f"'{key}' must be a non-empty string."
                    errors.append(errorMessage)
                if key == FrontmatterField.ID.value:
                    try:
                        uuid.UUID(value)
                    except ValueError as e:
                        errors.append(f"'{key}' is not a valid UUID.")
            case FrontmatterField.TAGS.value:
                if not (isinstance(value, list) 
                        and len(value) > 0 
                        and all(isinstance(e, str) and e in VALID_TAGS for e in value)):
                    errors.append(f"'{key}' must be a list of valid tags ({', '.join(sorted(VALID_TAGS))})")
            case FrontmatterField.ORDER.value:
                if not (isinstance(value, int) and value > 0):
                    errors.append(f"'{key}' must be a positive integer")

    return ValidationResult(ok = not errors, errors = errors)

def insert_frontmatter(path: Path) -> None:
    """Prepend delimiter + banner + frontmatter if missing. """
    existing_content = path.read_text(encoding="utf-8")
    frontmatter_dicc = asdict(Frontmatter(category=path.parent.name, id=str(uuid.uuid4())))
    frontmatter_yaml = yaml.safe_dump(frontmatter_dicc, sort_keys=False, default_flow_style=False)
    frontmatter_block = (
        f"{FRONTMATTER_DELIMITER}"
        f"{FRONTMATTER_BANNER}"
        f"{frontmatter_yaml}"
        f"{FRONTMATTER_DELIMITER}\n"
    )
    path.write_text(frontmatter_block + existing_content, encoding="utf-8", newline="\n")

@dataclass
class _Seen:
    titles: set = field(default_factory=set)
    orders: set = field(default_factory=set)
    ids: set = field(default_factory=set)

def validate_unique_fields_per_category(frontmatters: list[dict[str, Any]]) -> ValidationResult:
    errors: list[str] = []
    def _append_error(category : str, field: str, value: any):
        errors.append( f"[Category: {category}] Field '{field}' must be unique. Duplicated value: '{value}'.")

    category_seen: dict[str, _Seen] = {}

    for fm in frontmatters:
        category = fm.get(FrontmatterField.CATEGORY.value)
        title = fm.get(FrontmatterField.TITLE.value)
        order = fm.get(FrontmatterField.ORDER.value)
        fid = fm.get(FrontmatterField.ID.value)

        if category not in category_seen:
            category_seen[category] = _Seen()

        seen = category_seen[category]

        if title in seen.titles:
            _append_error(category, FrontmatterField.TITLE.value, title)
        else:
            seen.titles.add(title)

        if order in seen.orders:
            _append_error(category, FrontmatterField.ORDER.value, order)
        else:
            seen.orders.add(order)

        if fid in seen.ids:
            _append_error(category, FrontmatterField.ID.value, fid)
        else:
            seen.ids.add(fid)
    
    return ValidationResult(ok = not errors, errors = errors)


def get_content_after_frontmatter(file_data: str) -> str:
    parts = re.split(r"^---\s*\n.*?\n---\s*\n?", file_data, maxsplit=1, flags=re.DOTALL)
    return parts[1] if len(parts) > 1 else file_data

def get_delete_request(frontmatter : dict[str, Any]) -> DeleteNoteRequest:
    return DeleteNoteRequest (
        category= frontmatter.get(FrontmatterField.CATEGORY.value),
        note_id=frontmatter.get(FrontmatterField.ID.value),
    )